#########################################################
##  This file was automatically generated by PyR@TE 3  ##
###                                                   ###
##                                                     ##
#  Model  : Goofy_Neutrino                              #
#  Author : Alves                                       #
#  Date   : 27.10.2025                                  #
#########################################################

import os
import time
import numpy as np
from sympy import flatten
from scipy.integrate import ode
import matplotlib.pyplot as plt

from RGEs import (beta_g_U1Y, beta_g_SU2L,
                  beta_Ynu, beta_lambdaN, beta_lambdaR, beta_lambdaL,
                  beta_lambdaH, beta_lambdaP, beta_lambdaS, beta_lambda1,
                  beta_m1,
                  beta_vH, beta_vS)


class Coupling():
    couplings = {}

    def __init__(self, name, couplingType, latex=None, shape = (), fromMat=None, cplx=False, isCplx=False, init=0, pos=None):
        self.name = name
        self.type = couplingType

        if latex is not None:
            self.latex = latex
        else:
            self.latex = self.name

        self.shape = shape
        self.is_matrix = ( shape != () )
        self.nb = self.shape[0]*self.shape[1] if self.is_matrix else 1
        self.cplx = cplx
        self.isCplx = isCplx

        self.initialValue = init if shape == () else np.zeros(shape)

        if fromMat is not None:
            self.pos = pos
            self.latex = '{' + fromMat.latex + '}' + self.name.replace(fromMat.name, '')
            return

        if couplingType not in self.couplings:
            self.couplings[couplingType] = []

        self.pos = sum([c.nb for cList in self.couplings.values() for c in cList])
        self.couplings[couplingType].append(self)

    def as_explicit(self, toList=False):
        if not self.is_matrix:
            return self

        nameFunc = lambda x: self.name+'_{' + str(1 + x // self.shape[1]) + str(1 + x % self.shape[1]) + '}'
        initFunc = lambda x: list(self.initialValue)[x // self.shape[1]][x % self.shape[1]]
        arrayFunc = np.vectorize(lambda x: Coupling(nameFunc(x), self.type, fromMat=self, init=initFunc(x), pos=self.pos+x, isCplx=self.isCplx))
        array = arrayFunc(np.reshape(range(self.nb), self.shape))

        if not toList:
            return array

        return [*array.flat]

    def getInitialValue(self, splitCplx=False):
        if self.is_matrix:
            if splitCplx and self.isCplx:
                [(np.real(el), np.imag(el)) for el in self.initialValue.flat]
            else:
                return [*self.initialValue.flat]
        if splitCplx and self.isCplx:
            return (np.real(self.initialValue), np.imag(self.initialValue))

        if not self.isCplx and np.imag(self.initialValue) != 0:
            raise ValueError(f"Error: the coupling {self.name} should not take complex values")
        return self.initialValue


class RGEsolver():
    """ This class contains the RGEs of the model, as well as pre-defined functions
    used to solve and plot them.

    The three following arguments may be provided:
        - initialScale:
            The energy scale at which the initial values are given
        - tmin, tmax :
            The lower and upper energy scales between which the running couplings are computed and plotted

    The initialScale can be different from tmin and tmax, the only requirement being that the initial value of the
    couplings are all given at the same scale."""

    translation = {'GaugeCouplings': 'Gauge Couplings',
                   'Yukawas': 'Yukawa Couplings',
                   'QuarticTerms': 'Quartic Couplings',
                   'TrilinearTerms' : 'Trilinear Couplings',
                   'ScalarMasses': 'Scalar Mass Couplings',
                   'FermionMasses': 'Fermion Mass Couplings',
                   'Vevs': 'Vacuum-expectation Values'}

    def __init__(self, name, initialScale = 0, tmin = 0, tmax = 20):
        if initialScale < tmin or initialScale > tmax:
            exit(f"The initial running scale must lie in the interval [tmin={tmin}, tmax={tmax}]")

        self.name = name
        Coupling.couplings = {}

        self.initialScale = initialScale
        self.tmin = tmin
        self.tmax = tmax

        self.kappa = lambda n: 1/(4*np.pi)**(2*n)
        self.kappaString = '1/(4*np.pi)**(2*n)'

        self.tList = []
        self.solutions = {}
        self.loops = {'GaugeCouplings' : 3, 
                      'Yukawas' : 2, 
                      'QuarticTerms' : 2, 
                      'ScalarMasses' : 2, 
                      'Vevs' : 2}

        # Gauge Couplings
        self.g_U1Y = Coupling('g_U1Y', 'GaugeCouplings')
        self.g_SU2L = Coupling('g_SU2L', 'GaugeCouplings')

        # Yukawa Couplings
        self.Ynu = Coupling('Ynu', 'Yukawas', latex='Y_\\nu', shape=(3,3))
        self.lambdaN = Coupling('lambdaN', 'Yukawas', latex='\\lambda_N', shape=(3,3))
        self.lambdaR = Coupling('lambdaR', 'Yukawas', latex='\\lambda_R', shape=(3,3))
        self.lambdaL = Coupling('lambdaL', 'Yukawas', latex='\\lambda_L', shape=(3,3))

        # Quartic Couplings
        self.lambdaH = Coupling('lambdaH', 'QuarticTerms', latex='\\lambda_H')
        self.lambdaP = Coupling('lambdaP', 'QuarticTerms', latex='\\lambda_P')
        self.lambdaS = Coupling('lambdaS', 'QuarticTerms', latex='\\lambda_S')
        self.lambda1 = Coupling('lambda1', 'QuarticTerms', latex='\\lambda_1')

        # Scalar Mass Couplings
        self.m1 = Coupling('m1', 'ScalarMasses', latex='{m_1}^2')

        # Vacuum-expectation Values
        #   For vevs the gauge must be fixed. Let's use for instance the Landau gauge :
        self.xiGauge = 0

        self.vH = Coupling('vH', 'Vevs', latex='v_H')
        self.vS = Coupling('vS', 'Vevs', latex='v_S')

        self.couplings = Coupling.couplings
        self.matrixCouplings = {c.name: np.vectorize(lambda x: x.name)(c.as_explicit())
                                for cList in self.couplings.values()
                                for c in cList if c.is_matrix}


    def extractCouplings(self, couplingsArray, couplingType):
        ret = []
        for c in self.couplings[couplingType]:
            if not c.is_matrix:
                ret.append(couplingsArray[c.pos])
            else:
                ret.append(np.matrix(np.reshape([couplingsArray[p] for p in range(c.pos, c.pos+c.nb)], c.shape)))
        return ret


    def fixGauge(self, xi):
        self.xiGauge = xi


    def betaFunction(self, t, couplingsArray):
        """ This function generates the numerical values of the model RGEs. It is called by the
            solver to provide the derivative of the couplings with respect to the energy scale."""

        g_U1Y, g_SU2L = self.extractCouplings(couplingsArray, 'GaugeCouplings')
        Ynu, lambdaN, lambdaR, lambdaL = self.extractCouplings(couplingsArray, 'Yukawas')
        lambdaH, lambdaP, lambdaS, lambda1 = self.extractCouplings(couplingsArray, 'QuarticTerms')
        m1, = self.extractCouplings(couplingsArray, 'ScalarMasses')
        vH, vS = self.extractCouplings(couplingsArray, 'Vevs')

        bg_U1Y, bg_SU2L = 2*[0]
        bYnu, blambdaN, blambdaR, blambdaL = 4*[0]
        blambdaH, blambdaP, blambdaS, blambda1 = 4*[0]
        bm1 = 0
        bvH, bvS = 2*[0]

        if self.loops['GaugeCouplings'] >= 1:
            bg_U1Y += beta_g_U1Y(1, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(1)*np.log(10)
            bg_SU2L += beta_g_SU2L(1, g_SU2L,g_U1Y,Ynu,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(1)*np.log(10)
        if self.loops['GaugeCouplings'] >= 2:
            bg_U1Y += beta_g_U1Y(2, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(2)*np.log(10)
            bg_SU2L += beta_g_SU2L(2, g_SU2L,g_U1Y,Ynu,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(2)*np.log(10)
        if self.loops['GaugeCouplings'] >= 3:
            bg_U1Y += beta_g_U1Y(3, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(3)*np.log(10)
            bg_SU2L += beta_g_SU2L(3, g_SU2L,g_U1Y,Ynu,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(3)*np.log(10)

        if self.loops['Yukawas'] >= 1:
            bYnu += beta_Ynu(1, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaL,lambdaH,lambdaP)*self.kappa(1)*np.log(10)
            blambdaN += beta_lambdaN(1, Ynu,lambdaN,lambdaR,lambdaL,g_U1Y,g_SU2L,lambdaP,lambdaS,lambda1)*self.kappa(1)*np.log(10)
            blambdaR += beta_lambdaR(1, Ynu,lambdaN,lambdaR,lambdaL,g_U1Y,g_SU2L,lambdaP,lambdaS,lambda1)*self.kappa(1)*np.log(10)
            blambdaL += beta_lambdaL(1, lambdaN,lambdaR,lambdaL,Ynu,lambdaP,lambdaS,lambda1)*self.kappa(1)*np.log(10)
        if self.loops['Yukawas'] >= 2:
            bYnu += beta_Ynu(2, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaL,lambdaH,lambdaP)*self.kappa(2)*np.log(10)
            blambdaN += beta_lambdaN(2, Ynu,lambdaN,lambdaR,lambdaL,g_U1Y,g_SU2L,lambdaP,lambdaS,lambda1)*self.kappa(2)*np.log(10)
            blambdaR += beta_lambdaR(2, Ynu,lambdaN,lambdaR,lambdaL,g_U1Y,g_SU2L,lambdaP,lambdaS,lambda1)*self.kappa(2)*np.log(10)
            blambdaL += beta_lambdaL(2, lambdaN,lambdaR,lambdaL,Ynu,lambdaP,lambdaS,lambda1)*self.kappa(2)*np.log(10)

        if self.loops['QuarticTerms'] >= 1:
            blambdaH += beta_lambdaH(1, g_U1Y,g_SU2L,Ynu,lambdaH,lambdaP,lambdaN,lambdaR,lambdaL)*self.kappa(1)*np.log(10)
            blambdaP += beta_lambdaP(1, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaL,lambdaH,lambdaP,lambdaS,lambda1)*self.kappa(1)*np.log(10)
            blambdaS += beta_lambdaS(1, lambdaN,lambdaR,lambdaL,lambdaP,lambdaS,lambda1,g_U1Y,g_SU2L,Ynu)*self.kappa(1)*np.log(10)
            blambda1 += beta_lambda1(1, lambdaN,lambdaR,lambdaL,lambdaS,lambda1,Ynu,lambdaP)*self.kappa(1)*np.log(10)
        if self.loops['QuarticTerms'] >= 2:
            blambdaH += beta_lambdaH(2, g_U1Y,g_SU2L,Ynu,lambdaH,lambdaP,lambdaN,lambdaR,lambdaL)*self.kappa(2)*np.log(10)
            blambdaP += beta_lambdaP(2, g_U1Y,g_SU2L,Ynu,lambdaN,lambdaR,lambdaL,lambdaH,lambdaP,lambdaS,lambda1)*self.kappa(2)*np.log(10)
            blambdaS += beta_lambdaS(2, lambdaN,lambdaR,lambdaL,lambdaP,lambdaS,lambda1,g_U1Y,g_SU2L,Ynu)*self.kappa(2)*np.log(10)
            blambda1 += beta_lambda1(2, lambdaN,lambdaR,lambdaL,lambdaS,lambda1,Ynu,lambdaP)*self.kappa(2)*np.log(10)

        if self.loops['ScalarMasses'] >= 1:
            bm1 += beta_m1(1, lambdaN,lambdaR,lambdaL,lambdaS,lambda1,m1,Ynu,lambdaP)*self.kappa(1)*np.log(10)
        if self.loops['ScalarMasses'] >= 2:
            bm1 += beta_m1(2, lambdaN,lambdaR,lambdaL,lambdaS,lambda1,m1,Ynu,lambdaP)*self.kappa(2)*np.log(10)

        if self.loops['Vevs'] >= 1:
            bvH += beta_vH(1, g_U1Y,g_SU2L,Ynu,vH,self.xiGauge,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(1)*np.log(10)
            bvS += beta_vS(1, lambdaN,lambdaR,lambdaL,vS,Ynu,lambdaP,lambdaS,lambda1)*self.kappa(1)*np.log(10)
        if self.loops['Vevs'] >= 2:
            bvH += beta_vH(2, g_U1Y,g_SU2L,Ynu,vH,self.xiGauge,lambdaN,lambdaR,lambdaH,lambdaP)*self.kappa(2)*np.log(10)
            bvS += beta_vS(2, lambdaN,lambdaR,lambdaL,vS,Ynu,lambdaP,lambdaS,lambda1)*self.kappa(2)*np.log(10)

        return [bg_U1Y, bg_SU2L, *bYnu.flat, *blambdaN.flat, *blambdaR.flat, *blambdaL.flat, blambdaH, blambdaP, blambdaS, blambda1, bm1, bvH, bvS]


    def printInitialConditions(self, returnString=False):
        """ This function displays the current running scheme and the initial values of the couplings.

        Its output may be copy-pasted 'as-is' by user to modify these parameters before solving the RGEs."""

        # Display the running scheme

        outputString = "\n# Running scheme :\n\n"

        s = f"{self.name}.loops = "
        outputString += s + str(self.loops).replace(', ', ',\n ' + ' '*len(s)) + '\n'

        # Display the initial values of the couplings
        for cType, cList in self.couplings.items():
            outputString += f"\n# {self.translation[cType]}\n\n"
            for c in cList:
                s = f"{self.name}.{c.name}.initialValue = "
                if not c.is_matrix:
                    s += str(c.initialValue)
                else:
                    sVal = '['
                    sVal += (',\n ' +  len(s)*' ').join([ str(el).replace(' ', ', ') for el in c.initialValue])
                    sVal += ']\n'
                    s += sVal
                outputString += s + '\n'

        if returnString:
            return outputString

        print(outputString)


    ##################
    # Solve function #
    ##################

    def solve(self, step=.1, Npoints=None):
        """ This function performs the actual solving of the system of RGEs, using scipy.ode.

        Either the step of the numerical integration may be provided by the user with 'step=[value]',
        OR the number of integration points with 'Npoints=[integer value]'."""

        self.allCouplings = flatten([c.as_explicit(toList=True) for cList in self.couplings.values() for c in cList])

        time0 = time.time()
        y0 = flatten([c.getInitialValue() for c in self.allCouplings])

        tmin = self.tmin
        tmax = self.tmax
        t0 = self.initialScale

        if Npoints is None:
            dt = step
        else:
            dt = (tmax-tmin)/(Npoints-1)

        solutions = {}
        for c in self.allCouplings:
            solutions[c.name] = []
        tList = []

        solver = ode(self.betaFunction).set_integrator('zvode', method='bdf')
        solver.set_initial_value(y0, t0)

        # Solve upwards
        while solver.successful() and solver.t < tmax + dt/2:
            tList.append(solver.t)
            for i, c in enumerate(self.allCouplings):
                y = solver.y[i]
                if abs(y.imag) > 1e-10 and not c.cplx:
                    c.cplx = True
                elif y.imag == 0:
                    y = y.real

                solutions[c.name].append(y)

            solver.integrate(solver.t+dt)

        if t0 > tmin:
        # If t0 > tmin, complete the solving going downwards
            solutions2 = {}
            for c in self.allCouplings:
                solutions2[c.name] = []
            tList2 = []

            solver.set_initial_value(y0, t0)
            # Solve downwards
            while solver.successful() and solver.t > tmin + dt/2:
                solver.integrate(solver.t-dt)

                tList2.append(solver.t)
                for i, c in enumerate(self.allCouplings):
                    y = solver.y[i]
                    if abs(y.imag) > 1e-10 and not c.cplx:
                        c.cplx = True
                    elif y.imag == 0:
                        y = y.real

                    solutions2[c.name].append(y)


            # Combine the two regions
            tList = tList2[::-1] + tList
            for c in self.allCouplings:
                solutions[c.name] = solutions2[c.name][::-1] + solutions[c.name]

        self.tList, self.solutions = np.array(tList), {k:np.array(v) for k,v in solutions.items()}

        for k,v in self.matrixCouplings.items():
            self.solutions[k] = np.zeros(v.shape).tolist()
            for i, l in enumerate(self.solutions[k]):
                for j in range(len(l)):
                    self.solutions[k][i][j] = self.solutions[v[i,j]].tolist()
            self.solutions[k] = np.array(self.solutions[k]).transpose([2,0,1])

        self.cppSolved = False
        print(f"System of RGEs solved in {time.time()-time0:.3f} seconds.")


    #################
    # Plot function #
    #################

    subPos = {1: [111], 2: [121, 122], 3:[221, 222, 212],
              4: [221, 222, 223, 224], 5:[231, 232, 233, 223, 224],
              6: [231, 232, 233, 234, 235, 236],
              7: [241, 242, 243, 244, 231, 232, 233]}

    def plot(self, figSize=(600, 600), subPlots=True, which={}, whichNot={}, printLoopLevel=True):
        """ Plot the running couplings.

        Several options may be given to this function:
            - figSize=(x,y):
                The figure dimensions in pixels.
            - subPlots=True/False :
                If True, plot all the various couplings in the same window. If False,
                produces one figure by coupling type.
            - which=... :
                The user may want to plot only one or several (types of) couplings. Usage:

                >>> which='GaugeCouplings'

                >>> which=('GaugeCouplings', 'QuarticTerms')

                >>> which={'GaugeCouplings': 'all', 'Yukawas': ['yt', 'yb']}

                >>> which={'GaugeCouplings': ['g1', 'g2], 'Yukawas': 'Yu_{33}'}
            - whichNot=... :
                Which types of coupling types are NOT to be plotted. Same usage as which.
                Note that 'which' and 'whichNot' cannot be used simultaneously.
            - printLoopLevel=True/False :
                The loop-levels of the computation are displayed in the title of the plots.
        """

        if self.solutions == {}:
            print("The system of RGEs must be solved before plotting the results.")
            return

        allCouplingsByType = {cType:[] for cType in self.couplings}

        for c in self.allCouplings:
            if not all([el == 0 for el in self.solutions[c.name]]):
                allCouplingsByType[c.type].append(c)

        if which != {} and whichNot != {}:
            print("Error in 'plot' function: Arguments 'which' and 'whichNot' cannot be used simultaneously.")
            return

        ########################################
        # Identify the couplings to be plotted #
        ########################################

        if type(which) == str:
            which = {which: 'all'}
        elif type(which) == tuple:
            which = {el: 'all' for el in which}
        if type(whichNot) == str:
            which = {which: 'all'}
        elif type(whichNot) == tuple:
            whichNot = {el: 'all' for el in whichNot}

        for cType, cList in list(allCouplingsByType.items()):
            couplingsToDelete = []
            toDelete = False
            if cList == []:
                toDelete = True
            if which != {}:
                if cType not in which:
                    toDelete = True
                elif which[cType] != 'all':
                    if type(which[cType]) == str:
                        which[cType] = [which[cType]]
                    tmpList = []
                    for el in which[cType]:
                        if el not in self.matrixCouplings:
                            tmpList.append(el)
                        else:
                            tmpList += [*self.matrixCouplings[el].flat]
                    couplingsToDelete = [c for c in cList if c.name not in tmpList]
            if whichNot != {}:
                if cType in whichNot:
                    if whichNot[cType] == 'all':
                        toDelete = True
                    else:
                        if type(whichNot[cType]) == str:
                            whichNot[cType] = [whichNot[cType]]
                        tmpList = []
                        for el in whichNot[cType]:
                            if el not in self.matrixCouplings:
                                tmpList.append(el)
                            else:
                                tmpList += [*self.matrixCouplings[el].flat]
                        couplingsToDelete = [c for c in cList if c.name in tmpList]

            if toDelete:
                del allCouplingsByType[cType]

            if couplingsToDelete != []:
                for c in couplingsToDelete:
                    if c in allCouplingsByType[cType]:
                        allCouplingsByType[cType].remove(c)


        ###################
        # Actual plotting #
        ###################

        if subPlots:
            plt.figure(figsize=(figSize[0]/80., figSize[0]/80.), dpi=80)

        for i, (cType, cList) in enumerate(allCouplingsByType.items()):
            title = self.translation[cType]
            if printLoopLevel:
                title = f"{self.loops[cType]}-loop " + title
            if not subPlots:
                plt.figure(figsize=(figSize[0]/80., figSize[0]/80.), dpi=80)
                plt.suptitle(title)
            else:
                plt.subplot(self.subPos[len(allCouplingsByType)][i])
                plt.title(title)

            cNames = []
            for c in cList:
                if not c.cplx:
                    if 'complex' not in str(self.solutions[c.name].dtype):
                        plt.plot(self.tList, self.solutions[c.name])
                    else:
                        plt.plot(self.tList, np.real(self.solutions[c.name]))
                    cNames.append('$' + c.latex + '$')
                else:
                    plt.plot(self.tList, np.real(self.solutions[c.name]))
                    plt.plot(self.tList, np.imag(self.solutions[c.name]))
                    cNames.append('$\\Re(' + c.latex + ')$')
                    cNames.append('$\\Im(' + c.latex + ')$')

            plt.legend(cNames)
            plt.xlabel(r't',fontsize=17-len(allCouplingsByType))
        plt.show()


    #########################
    # Save / load functions #
    #########################

    def save(self, fileName):
        try:
            import pickle
        except:
            print("Error: unable to load the 'pickle' module.")
            return

        storeKappa = self.kappa
        self.kappa = None

        try:
            if '.' not in fileName:
                fileName += '.save'
            print(f"Saving the RGE object in file '{fileName}'...", end='')
            file = open(fileName, 'wb')
            pickle.dump(self, file)
        except BaseException as e:
            print("\nAn error occurred while saving the rge object :")
            print(e)
            return
        else:
            file.close()
            print(" Done.")

        self.kappa = storeKappa

    def load(fileName):
        import os
        try:
            import pickle
        except:
            print("Error: unable to load the 'pickle' module.")
            return

        if not os.path.exists(fileName):
            print(f"Error: The file '{fileName}' doesn't exist.")
            return None

        try:
            print(f"Loading the RGE object from file '{fileName}'...", end='')
            file = open(fileName, 'rb')
            rge = pickle.load(file)
        except BaseException as e:
            print("\nAn error occurred while loading the rge object :")
            print(e)
        else:
            print(" Done.")
        finally:
            file.close()

        rge.kappa = eval('lambda n:' + rge.kappaString)
        return rge

